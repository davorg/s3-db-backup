#! /usr/bin/perl

use v5.10;
use strict;
use warnings;

use Getopt::Long qw<GetOptions :config gnu_getopt>;
use DateTime;

my $USAGE = <<'EOF';
Usage: db_backup [OPTION]...

Back up databases, and clean up old backups.  Expects to be run hourly.

Options:

  --verbose Verbose mode
  --username USER
      Connect to the database as the given USER (required)
  --password PASSWORD
      Connect to the database with the given PASSWORD
  --directory BACKUP_DIR
      Store and delete backups in the given BACKUP_DIR (required)
  --Prefix PREFIX
      Fixed part of filename
  --Bucket Amazon S3 bucket to use

EOF

GetOptions(\my %OPT, qw<help|? version username=s password=s database|db=s
                        directory=s timestamp=s Prefix=s Bucket=s>)
    or die $USAGE;

if ($OPT{help}) {
    print $USAGE;
    exit 0;
}

for (qw<username database>) {
    die "The -$_ option is required" if !exists $OPT{$_};
}

$OPT{Prefix} //= 'magnum_db.sql';

my $app = S3::MySQL::Backup->new(\%OPT);
$app->run;

package S3::MySQL::Backup;

use Moo;
use Types::Standard qw[Str];

has [qw<username database>] => (
    is => 'ro',
    isa => Str,
    required => 1,
);

has [qw<password directory timestamp Prefix Bucket>]=> (
    is => 'ro',
    isa => Str,
);


sub run {
    my $self = shift;

    chdir $self->directory
        or die "Can't chdir to ", $self->direcotry, ": $!\n";
    my $now = $self->now();
    my %wanted = map { $_ => 1 } $self->times_to_keep($now);
    my @to_delete;
    my $prefix = $self->prefix;
    for (glob "$prefix.*") {
        my ($ymdh) = /\A\Q$prefix\E\.([0-9]{10})[0-9]{2}\.gz\z/xms or next;
        push @to_delete, $_ if !$wanted{$ymdh};
    }
    $self->note('Generating backup for ', $now->iso8601);
    $self->backup($prefix . $now->strftime('.%Y%m%d%H%M'));
    if (@to_delete) {
        $self->note('Cleaning up ', scalar @to_delete, ' old backups');
        for (@to_delete) {
            unlink $_ or die "Can't delete $_: $!\n";
            if (my $bucket = $self->bucket) {
                $self->note("Deleting $_ from S3");
                system "s3cmd --no-progress del s3://$bucket/$_";
            }
        }
    }
    $self->note('All done!');
}

sub backup {
    my $self = shift;
    my ($output_file) = @_;

    $output_file .= '.gz' unless $output_file =~ /\.gz$/;

    my $user = $self->username;
    my @creds = "-u\Q$user\E";
    if (defined $self->password) {
        my $pass = $self->password;
        push @creds, "-p\Q$pass\E";
    }

    system "mysqldump --opt @creds --all-databases | gzip > \Q$output_file\E";
    my $dir = $self->dir;
    if ($? != 0) {
        unlink $output_file
            or die "Can't delete incomplete $dir/$output_file: $!\n";
        die "mysqldump exited unsuccessfully; no backup created\n";
    }

    if ($self->bucket && -e $output_file) {
        system "s3cmd --no-progress put $output_file s3://" . $self->bucket . "/";
    }
}

sub now {
    my $self = shift;

    return DateTime->now if !$self->timestamp;
    my $rx = join '[^0-9]', ('([0-9]+)') x 6;
    my ($y, $m, $d, $h, $i, $s) = $self->timestamp =~ /\A$rx\z/xms
        or die "Can't parse date/time\n";
    return DateTime->new(
        year => $y, month  => $m, day    => $d,
        hour => $h, minute => $i, second => $s,
    );
}

sub times_to_keep {
    my ($now) = @_;
    my @times;
    my $dt = $now->clone->add(hours => 1);
    for (1 .. 24) {
        $dt->subtract(hours => 1);
        push @times, $dt->clone;
    }
    if ($dt->hour == 0) {
        $dt->subtract(days => 1);
    }
    else {
        $dt->set_hour(0);
    }
    for (1 .. 7) {
        push @times, $dt->clone;
        $dt->subtract(days => 1);
    }
    return map { $_->strftime('%Y%m%d%H') } reverse @times;
}

sub note {
    my $self = shift;
    say STDERR @_ if $self->verbose;
}
